#!/usr/bin/env swift

#if os(OSX)
    import Darwin
#else
    import Glibc
#endif

import Foundation

class Vapor {
    /// Space separated args from shell
    var arguments: [String]

    /// True if the --release flag was passed
    var release = false

    /// Enables more detailed logs
    var verbose = false

    /// Any arguments starting with --
    var flags: [String]

    /**
        Intializes the CLI from an
        array of arguments received from the shell.

        - parameter arguments: Space separated args from shell
    */
    init(arguments: [String]) {
        var commands: [String] = []
        var flags: [String] = []

        for argument in arguments {
            if argument.characters.first == "-" {
                if argument == "--release" {
                    release = true
                } else if argument == "--verbose" {
                    verbose = true
                    flags.append(argument)
                } else {
                    flags.append(argument)
                }
            } else {
                commands.append(argument)
            }
        }

        self.arguments = commands
        self.flags = flags

        if commands.count < 2 {
            printUsage()
            fail("Invalid number of arguments.")
        }
    }
    /**
        Starts the CLI and determines
        which command should run, if any.
    */
    func start() {
        if let command = Command(rawValue: arguments[1]) {

            #if os(OSX)
            switch command {
            case .Clean:
                clean()
            case .Build:
                build()
            case .Run:
                run()
            case .New:
                newProject()
            case .Help:
                help()
            case .SelfUpdate:
                selfUpdate()
            case .SetupHeroku:
                setupHeroku()
            case .Xcode:
                xcode()
            }
            #else
            switch command {
            case .Clean:
                clean()
            case .Build:
                build()
            case .Run:
                run()
            case .New:
                newProject()
            case .Help:
                help()
            case .SelfUpdate:
                selfUpdate()
            case .SetupHeroku:
                setupHeroku()
            }
            #endif

        } else {
            fail("Unknown command: \(Process.arguments[1])")
        }
    }

    enum Error: ErrorProtocol {
        case System(Int32)
        case Cancelled
    }

    /**
        The available commands.
    */
    enum Command: String {
        case Clean = "clean"
        case Build = "build"
        case Run = "run"
        case New = "new"
        case Help = "help"
        case SelfUpdate = "self-update"
        case SetupHeroku = "setup-heroku"
        #if os(OSX)
        case Xcode = "xcode"
        #endif

        #if os(OSX)
        static var all: [Command] = [.Clean, .Build, .Run, .New, .Help, .SelfUpdate, .SetupHeroku, .Xcode]
        #else
        static var all: [Command] = [.Clean, .Build, .Run, .New, .Help, .SelfUpdate, .SetupHeroku]
        #endif
    }

    /**
        Prints out usage information
        including available commands.
    */
    func printUsage() {
        let names = Command.all.map { command in
            return command.rawValue
        }

        print("Usage: \(arguments[0]) [\(names.joined(separator: "|"))]")
    }

    /**
        Attempts to run the supplied
        command or throws an error.

        - parameter command: Command to run
    */
    func run(_ command: String) throws {
        let result = system(command)

        if result == 2 {
            throw Error.Cancelled
        } else if result != 0 {
            throw Error.System(result)
        }
    }

    /**
        Runs the supplied command in
        the shell or prints the supplied
        error message if the command fails.

        - parameter command: Command to run
        - parameter errorMessage: Prints if command fails
    */
    func run(_ command: String, orFail errorMessage: String) {
        do {
            try run(command)
        } catch {
            fail(errorMessage)
        }
    }

    /**
        Prints out an error message
        and exits the script.

        - parameter message: Error message to print
    */
    @noreturn func fail(_ message: String) {
        print()
        print("Error: \(message)")
        exit(1)
    }

    /**
        Removes the Packages and .build
        folders from the current directory.
    */
    func clean() {
        run("rm -rf Packages .build", orFail: "Could not clean")
        print("Cleaned.")
    }

    /**
        Attempts to compile the Vapor
        project in the current directory.
    */
    func build() {
        do {
            var buildFlags = flags.joined(separator: " ")
            if release {
                buildFlags += " -c release"
            }
            try run("swift build \(buildFlags)")
        } catch Error.Cancelled {
            fail("Build cancelled.")
        } catch {
            print()
            print("Make sure you are running Apple Swift version 3.0.")
            print("Vapor only supports the latest snapshot.")
            print("Run swift --version to check your version.")

            fail("Could not build project.")
        }
    }

    /**
        Attempts to run the Vapor
        project in the current directory.
    */
    func run() {
        print("Running...")
        do {
            var name = "App"
            let folder = release ? "release" : "debug"

            if arguments.count >= 3 {
                name = arguments[2]
            }

            let flagString = flags.joined(separator: " ")
            try run(".build/\(folder)/\(name) \(flagString)")
        } catch Error.Cancelled {
            fail("Run cancelled.")
        } catch {
            fail("Could not run project.")
        }
    }

    /**
        Clones the Vapor Example
        project as a boilerplate.
    */
    func newProject() {
        if arguments.count < 3 {
            print("Usage: \(arguments[0]) \(arguments[1]) <project-name>")
            fail("Invalid number of arguments.")
        }
        let name = arguments[2]

        let wgetArgs = verbose ? "" : "-q"
        let tarArgs = verbose ? "v" : ""

        do {
            let escapedName = "\"\(name)\"" // FIX: Doesnâ€™t support names with quotes
            try run("mkdir \(escapedName)")

            guard commandExists("wget") else {
              fail("wget required to create new project. Recommended to install through Homebrew: http://brew.sh/")
            }
            try run("wget \(wgetArgs) https://github.com/qutheory/vapor-example/archive/master.tar.gz -O \(escapedName)/vapor-example.tar.gz")
            try run("tar -\(tarArgs)xzf \(escapedName)/vapor-example.tar.gz --strip-components=1 --directory \(escapedName)")
            try run("rm \(escapedName)/vapor-example.tar.gz")
            #if os(OSX)
              try run("cd \(escapedName) && swift build -X")
            #endif

            if commandExists("git") {
              print("Initializing git repository if necessary")
              system("git init \(escapedName)")
              system("cd \(escapedName) && git add . && git commit -m \"initial vapor project setup\"")
              print()
            }

            print()
            print("Project \"\(name)\" has been created.")
            print("Enjoy!")
            print()
            system("open \(escapedName)/VaporApp.xcodeproj")
        } catch {
            fail("Could not clone repository")
        }
    }

    /**
        Updates this CLI script
        in the bin from the latest version online.
    */
    func selfUpdate() {
        let name = "vapor-cli.tmp"
        let flags = verbose ? "" : "-q"
        let installLoc = arguments[0]

        do {
            print("Downloading...")
            try run("wget \(flags) cli.qutheory.io -O \(name)")
        } catch {
            print("Could not download Vapor CLI.")
            print("Make sure you have 'wget' installed.")
            return
        }

        do {
            try run("chmod +x \(name)")
            try run("mv \(name) \(installLoc)")
        } catch {
            print("Could not move Vapor CLI to install location.")
            print("Trying with 'sudo'.")
            do {
                try run("sudo mv \(name) \(installLoc)")
            } catch {
                print("Still could not move Vapor CLI to install location, giving up.")
                return
            }
        }

        print("Vapor CLI updated.")
    }

    #if os(OSX)
    /**
        Generates and opens an Xcode
        project for Vapor module in the current dir.
    */
    func xcode() {
        print("Generating Xcode Project...")

        do {
            try run("swift build --generate-xcodeproj")
        } catch Error.System(let result) {
            if result == 256 {
                print()
                print("Clean the project and try again.")
                print("Run: vapor clean")
            }
            fail("Could not generate Xcode Project.")
        } catch {
            print("other")
            fail("Could not generate Xcode Project.")
        }

        print("Opening Xcode...")

        do {
            try run("open *.xcodeproj")
        } catch {
            fail("Could not open Xcode Project.")
        }
    }
    #endif

    /**
        Displays information about how to use
        the CLI and what its various commands do.
    */
    func help() {
        print()
        printUsage()
        print()
        print("Flags:")
        print("  --release")
        print("    Builds and runs with optimizations")
        print()
        print("  --verbose")
        print()
        print("Options:")
        print("  build [file1, file2, ...]")
        print("    Builds source files and links Vapor libs.")
        print("    Defaults to App/ folder structure.")
        print()
        print("  run")
        print("    Runs the executable built by vapor build.")
        print("    To pass arguments to the program, ")
        print("    run it manually .build/VaporApp")
        print()
        print("  new <project-name>")
        print("    Clones the Vapor Example to a given ")
        print("    folder name and initializes an empty")
        print("    Git repository inside it.")
        print()
        print("  self-update")
        print("    Downloads the latest version of")
        print("    the Vapor command line interface.")

        #if os(OSX)
        print()
        print("  xcode")
        print("    Generates and opens an Xcode Project.")
        #endif

        print("  setup-heroku")
        print("    creates and starts a basic heroku project")

        print()
        print("  clean")
        print()
        print("  help")
        print()
        print("Community:")
        print("  Join our Slack if you have questions, ")
        print("  need help, or want to contribute.")
        print("  http://slack.qutheory.io")
        print()
    }
}

extension Vapor {
  func gitHistoryIsClean() -> Bool {
    return system("test -z \"$(git status --porcelain)\" || exit 1") == 0
  }

  func getInput() -> String {
    return readLine(strippingNewline: true) ?? ""
  }

  func readPackageSwiftFile() -> String {
    let file = "./Package.swift"
    do {
      return try String(contentsOfFile: file)
    } catch {
      print()
      print("Unable to find Package.swift")
      print("Make sure you've run `vapor new` or setup your Swift project manually")
      fail("")
    }
  }

  func extractPackageName(from packageFile: String) -> String {
    let packageName = packageFile
      .components(separatedBy: "\n")
      .lazy
      .map { $0.trimmedSpaces() }
      .filter { $0.hasPrefix("name") }
      .first?
      .components(separatedBy: "\"")
      .lazy
      .filter { !$0.hasPrefix("name") }
      .first

    guard let name = packageName else {
      fail("Unable to extract package name")
    }

    return name
  }

  func getPackageName() -> String {
    let packageFile = readPackageSwiftFile()
    let packageName = extractPackageName(from: packageFile)
    return packageName
  }

  func setupHeroku() {
    guard commandExists("git") else {
      fail("git is required to setup heroku, make sure it's installed")
    }
    guard commandExists("heroku") else {
      fail("heroku cli and logged in user is required: https://toolbelt.heroku.com/")
    }

    if !gitHistoryIsClean() {
      print("Found Uncommitted Changes")
      print("Setting up heroku requires adding a commit to the repository")
      print("Please commit your current changes before setting up heroku")
      fail("")
    }

    let packageName = getPackageName()
    print("Setting up Heroku for \(packageName) ...")
    print()
    print("Custom Buildpack? (return to use default)")

    var buildpack = ""
    if let input = readLine(strippingNewline: true) where !buildpack.isEmpty {
      buildpack = input
    } else {
      // TODO: Move default to KyleF when supported
      buildpack = "https://github.com/qutheory/heroku-buildpack-swift"
    }
    print("Using buildpack: \(buildpack)")
    print()

    print("Custom Heroku App Name? (return to let Heroku create)")
    let herokuAppName = getInput()
    do {
      try run("heroku create \(herokuAppName) --buildpack \(buildpack)")
    } catch {
      fail("")
    }

    print("Creating Procfile ...")
    // TODO: Discuss
    // Should it be
    //    let procContents = "web: \(packageName) --port=\\$PORT"
    // It causes errors like that and forces `App` as process.
    // Forces us to use Vapor CLI
    // Maybe that's something we want
    let procContents = "web: App --port=\\$PORT"
    do {
      // Overwrites existing Procfile
      try run("echo \"\(procContents)\" > ./Procfile")
    } catch {
      fail("Unable to make Procfile")
    }

    print()
    print("Would you like to push to heroku now? (y/n)")
    let input = getInput().lowercased()
    if input.hasPrefix("n") {
      print("\n\n")
      print("Make sure to push your changes to heroku using:")
      print("\t'git push heroku master'")
      print("You may need to scale up dynos")
      print("\t'heroku ps:scale web=1'")
      exit(0)
    }

    print()
    print("Pushing to heroku ... this could take a while")
    print()

    system("git add .")
    system("git commit -m \"setting up heroku\"")
    system("git push heroku master")

    print("spinning up dynos ...")
    do {
      try run("heroku ps:scale web=1")
    } catch {
      fail("unable to spin up dynos")
    }
  }

  func commandExists(_ command: String) -> Bool {
    return system("hash \(command) 2>/dev/null") == 0
  }
}

extension String {
  func trimmedSpaces() -> String {
    // while characters
    var mutable = self
    while let next = mutable.characters.first where next == " " {
      mutable.remove(at: mutable.startIndex)
    }
    while let next = mutable.characters.last where next == " " {
      mutable.remove(at: mutable.startIndex)
    }
    return mutable
  }
}

let cli = Vapor(arguments: Process.arguments)
cli.start()

exit(0)
